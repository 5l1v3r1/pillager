<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# hunter

```go
import "github.com/brittonhayes/pillager/pkg/hunter"
```

Package hunter contains the types\, methods\, and interfaces for the file hunting portion of pillager

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CheckPath(fs afero.Fs, path string) string](<#func-checkpath>)
- [func FilterResults(github bool, telephone bool, email bool) []*regexp.Regexp](<#func-filterresults>)
- [func LoadRules(filepath string) []gitleaks.Rule](<#func-loadrules>)
- [func RenderTemplate(w io.Writer, tpl string, f []Finding)](<#func-rendertemplate>)
- [type Config](<#type-config>)
  - [func (c *Config) Default() *Config](<#func-config-default>)
- [type Finding](<#type-finding>)
- [type Findings](<#type-findings>)
  - [func (ss Findings) Filter(condition func(Finding) bool) (ss2 Findings)](<#func-findings-filter>)
- [type Format](<#type-format>)
  - [func StringToFormat(s string) Format](<#func-stringtoformat>)
  - [func (f Format) String() string](<#func-format-string>)
- [type Hound](<#type-hound>)
  - [func NewHound(c *Config) *Hound](<#func-newhound>)
  - [func (h Hound) Fetch()](<#func-hound-fetch>)
  - [func (h *Hound) FilterEmpty() *Hound](<#func-hound-filterempty>)
- [type Hunter](<#type-hunter>)
  - [func NewHunter(c *Config) *Hunter](<#func-newhunter>)
  - [func (h Hunter) Hunt() error](<#func-hunter-hunt>)
  - [func (h Hunter) Inspect(path string, fs afero.Fs)](<#func-hunter-inspect>)
- [type Hunting](<#type-hunting>)
- [type Retriever](<#type-retriever>)


## Constants

DefaultTemplate is the base template used to format a Finding into the custom output format

```go
const DefaultTemplate = `{{ range . -}}
{{ if (ge .Count 1) -}}PATH: {{.Path}}
COUNT: {{.Count}}
{{ range .Loot -}}Loot: {{.}}
{{end}}
{{end}}
{{- end}}`
```

## Variables

```go
var DefaultPatterns = []*regexp.Regexp{
    reg.EmailRegex,
    reg.GitRepoRegex,
}
```

## func [CheckPath](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/helpers.go#L11>)

```go
func CheckPath(fs afero.Fs, path string) string
```

CheckPath checks if a filepath exists and returns it if so\, otherwise returns a default path

## func [FilterResults](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hunter.go#L143>)

```go
func FilterResults(github bool, telephone bool, email bool) []*regexp.Regexp
```

FilterResults sets the patterns to hunt for based on provided filters

## func [LoadRules](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/config.go#L41>)

```go
func LoadRules(filepath string) []gitleaks.Rule
```

## func [RenderTemplate](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/template.go#L21>)

```go
func RenderTemplate(w io.Writer, tpl string, f []Finding)
```

RenderTemplate renders a Hound finding in a custom go template format to the provided writer

## type [Config](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/config.go#L20-L26>)

Config takes all of the configurable parameters for a Hunter

```go
type Config struct {
    System   afero.Fs
    BasePath string
    Verbose  bool
    Rules    []gitleaks.Rule
    Format   Format
}
```

### func \(\*Config\) [Default](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/config.go#L30>)

```go
func (c *Config) Default() *Config
```

Default loads the default configuration for the Hunter

## type [Finding](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L32-L37>)

Finding houses the details of a hound's hunt

```go
type Finding struct {
    Count   int      `json:"count,omitempty"`
    Message string   `json:"message,omitempty"`
    Path    string   `json:"path,omitempty"`
    Loot    []string `json:"loot,omitempty"`
}
```

## type [Findings](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L29>)

Findings contains a slice of Finding

```go
type Findings []Finding
```

### func \(Findings\) [Filter](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/findings_pie.go#L7>)

```go
func (ss Findings) Filter(condition func(Finding) bool) (ss2 Findings)
```

Filter will return a new slice containing only the elements that return true from the condition\. The returned slice may contain zero elements \(nil\)\.

FilterNot works in the opposite way of Filter\.

## type [Format](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/format.go#L9>)

```go
type Format int
```

```go
const (
    JSONFormat Format = iota + 1
    YAMLFormat
    CustomFormat
)
```

### func [StringToFormat](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/helpers.go#L28>)

```go
func StringToFormat(s string) Format
```

StringToFormat takes in a string representation of the preferred output format and returns to enum equivalent

### func \(Format\) [String](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/format.go#L11>)

```go
func (f Format) String() string
```

## type [Hound](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L23-L26>)

A Hound performs the file inspection and returns the results

```go
type Hound struct {
    Config   *Config
    Findings Findings `json:"findings"`
}
```

### func [NewHound](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L40>)

```go
func NewHound(c *Config) *Hound
```

NewHound creates an instance of the Hound type

### func \(Hound\) [Fetch](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L53>)

```go
func (h Hound) Fetch()
```

Fetch prints out the Findings from the Hound in the preferred output format

<details><summary>Example</summary>
<p>

Here is an example of utilizing the Howl function on a slice of findings\. The Howl method is the final method in the hunting process\. It takes whatever has been found and outputs it for the user\.

```go
{
	h := NewHound(&Config{
		System: afero.NewMemMapFs(),
		Rules:  LoadRules(""),
		Format: JSONFormat,
	})
	h.Findings = []Finding{
		{
			Count:   1,
			Message: "Found something juicy",
			Path:    "example.toml",
			Loot:    []string{"Token 1234560"},
		},
	}
	h.Fetch()

}
```

#### Output

```
[{"count":1,"message":"Found something juicy","path":"example.toml","loot":["Token 1234560"]}]
```

</p>
</details>

### func \(\*Hound\) [FilterEmpty](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L73>)

```go
func (h *Hound) FilterEmpty() *Hound
```

## type [Hunter](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hunter.go#L16-L19>)

Hunter holds the required fields to implement the Hunting interface and utilize the hunter package

```go
type Hunter struct {
    Config *Config
    Hound  *Hound
}
```

### func [NewHunter](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hunter.go#L30>)

```go
func NewHunter(c *Config) *Hunter
```

NewHunter creates an instance of the Hunter type

### func \(Hunter\) [Hunt](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hunter.go#L43>)

```go
func (h Hunter) Hunt() error
```

Hunt walks over the filesystem at the configured path\, looking for sensitive information it implements the Inspect method over an entire directory

### func \(Hunter\) [Inspect](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hunter.go#L66>)

```go
func (h Hunter) Inspect(path string, fs afero.Fs)
```

Inspect digs into the provided file and concurrently scans it for sensitive information

<details><summary>Example</summary>
<p>

This method also accepts custom output formats using go template/html\. So if you don't like yaml or json\, you can format to your heart's content\.

```go
{
	fs := afero.NewMemMapFs()
	f, err := fs.Create("example.yaml")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	_, err = f.Write([]byte(`https://github.com/brittonhayes/pillager`))
	if err != nil {
		panic(err)
	}

	c := Config{
		System:   fs,
		BasePath: ".",
		Verbose:  true,
		Format:   CustomFormat,
	}
	h := NewHunter(&c)
	h.Inspect(f.Name(), h.Config.System)
}
```

</p>
</details>

<details><summary>Example</summary>
<p>

This is an example of how to run a scan on a single file to look for email addresses\. We're using an in\-memory file system for simplicity\, but this supports using an actual file system as well\.

```go
{
	fs := afero.NewMemMapFs()
	f, err := fs.Create("example.toml")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	_, err = f.Write([]byte(`example@email.com`))
	if err != nil {
		panic(err)
	}

	c := Config{
		System:   fs,
		BasePath: CheckPath(fs, "."),
		Verbose:  true,
		Format:   StringToFormat("yaml"),
		Rules:    LoadRules(""),
	}
	h := NewHunter(&c)
	h.Inspect(f.Name(), h.Config.System)

}
```

#### Output

```
- count: 1
  loot:
  - example@email.com
  message: '[+] Scanning: example.toml'
  path: example.toml
```

</p>
</details>

<details><summary>Example</summary>
<p>

This method accepts json output format as well

```go
{
	fs := afero.NewMemMapFs()
	f, err := fs.Create("fake.json")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = f.Write([]byte(`git@github.com:brittonhayes/pillager.git`))
	if err != nil {
		panic(err)
	}

	h := NewHunter(&Config{
		System:   fs,
		BasePath: ".",
		Verbose:  true,
		Format:   JSONFormat,
		Rules:    LoadRules(""),
	})
	h.Inspect(f.Name(), h.Config.System)

}
```

#### Output

```
[{"count":2,"message":"[+] Scanning: fake.json","path":"fake.json","loot":["git@github.com","git@github.com:brittonhayes/pillager.git"]}]
```

</p>
</details>

<details><summary>Example</summary>
<p>

Hunter will also look personally identifiable info in TOML

```go
{
	fs := afero.NewMemMapFs()
	f, err := fs.Create("fake.toml")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = f.Write([]byte(`fakeperson@example.com`))
	if err != nil {
		panic(err)
	}

	h := NewHunter(&Config{
		System:   fs,
		Rules:    LoadRules(""),
		BasePath: CheckPath(fs, "."),
		Verbose:  true,
		Format:   JSONFormat,
	})
	h.Inspect(f.Name(), h.Config.System)

}
```

#### Output

```
[{"count":1,"message":"[+] Scanning: fake.toml","path":"fake.toml","loot":["fakeperson@example.com"]}]
```

</p>
</details>

## type [Hunting](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hunter.go#L24-L27>)

Hunting is the primary API interface for the hunter package

```go
type Hunting interface {
    Hunt() error
    Inspect(path string, fs afero.Fs)
}
```

## type [Retriever](<https://github.com/brittonhayes/pillager/blob/main/pkg/hunter/hound.go#L17-L20>)

The Retriever interface defines the available methods for instances of the Hound type

```go
type Retriever interface {
    FilterEmpty() *Hound
    Fetch()
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
